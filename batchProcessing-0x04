#!/bin/bash

# Configuration
POKEMON_LIST=("bulbasaur" "ivysaur" "venusaur" "charmander" "charmeleon")
API_BASE="https://pokeapi.co/api/v2/pokemon"
MAX_PARALLEL=3  # Optimal number of parallel requests
OUTPUT_DIR="pokemon_data"
ERROR_LOG="pokemon_errors.log"

# Create directories and initialize logs
mkdir -p "$OUTPUT_DIR"
> "$ERROR_LOG"

# Function to fetch a single Pok√©mon
fetch_pokemon() {
    local pokemon=$1
    local output_file="${OUTPUT_DIR}/${pokemon}.json"
    
    if curl -s -f --max-time 30 "${API_BASE}/${pokemon}" -o "$output_file" 2>> "$ERROR_LOG"; then
        echo "‚úÖ $pokemon fetched successfully"
    else
        echo "‚ùå Failed to fetch $pokemon" >> "$ERROR_LOG"
        rm -f "$output_file"
        return 1
    fi
}

# Main execution
echo "Starting parallel Pok√©mon fetch at $(date)"
echo "======================================"
echo "Processing ${#POKEMON_LIST[@]} Pok√©mon with $MAX_PARALLEL parallel workers"

# Initialize process tracking
declare -a pid_array
completed=0

# Process Pok√©mon in batches
for ((i=0; i<${#POKEMON_LIST[@]}; i+=MAX_PARALLEL)); do
    # Launch parallel batch
    for ((j=0; j<MAX_PARALLEL && i+j<${#POKEMON_LIST[@]}; j++)); do
        pokemon="${POKEMON_LIST[$((i+j))]}"
        fetch_pokemon "$pokemon" &
        pid_array+=($!)
        echo "üîÑ Started process $! for $pokemon"
    done
    
    # Wait for current batch to complete
    for pid in "${pid_array[@]}"; do
        wait "$pid" && ((completed++))
    done
    pid_array=()  # Reset for next batch
done

# Final summary
echo "======================================"
echo "Completed at $(date)"
success_count=$(ls -1 "$OUTPUT_DIR" 2>/dev/null | wc -l)
echo "Results: $success_count/${#POKEMON_LIST[@]} Pok√©mon fetched successfully"
[ -s "$ERROR_LOG" ] && echo "Errors logged in: $ERROR_LOG"
echo "Parallel fetch operation completed!"